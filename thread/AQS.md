### 抽象的同步队列
- 双向队列，volatile，CAS构成了AQS的核心
- 维护了一个head和tail变量，分别指向队列的队尾和队首
- 维护了一个state变量，可重入的意思就是每加锁一次这个值就加一

### 独占锁加锁流程
- 尝试CAS操作将state加一的时候，成功则返回，失败则CAS失败重试的方式将当前线程的node加入队尾
- 线程获取锁是一个自旋（死循环）的过程，当节点的前驱节点是头节点的时候并且当前线程成功获取同步状态的时候，当前节点出队并且获得锁，否则调用LockSupport方法使当前线程阻塞

### 独占锁释放锁
- 线程封装在队列的头节点中，释放锁时会CAS将state置为0；同时唤醒他的后继节点
- 后继节点醒过来，发现他的前驱节点是头节点并且成功将state加一，则将头节点断链，方便GC

### 可响应中断的独占锁
其实就是在线程阻塞的时候判断是否被中断，中断则抛出中断异常

### 超时等待式获取锁
- 计算出线程等待的截至时间
- 在线程自旋获取锁的过程中，会判断当前时间是否大于截至时间，大于直接返回false

---
### 共享锁的实现 读写锁ReentrantReadWriteLock
- 由state的高16位维护读锁，低16位维护写锁
- 写锁相当于独享锁，判断是否锁的关键是，将state & (1<<16)-1 ,获得值是否为0,为0表示没有读锁或者写锁
- 读锁加锁时是将state加上1<<16，表示读锁的加锁次数

