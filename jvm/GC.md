### GC工作区域
- heap区（堆）
- MetaSpace 区(替代已有的方法区)
- -XX:MaxPermSize设置大小

### GC时机
- Minor GC触发条件：当Eden区满时，触发Minor GC
- Full GC触发条件
    - 老年代空间不足
    - 方法去空间不足
    - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    - 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小


### 找到垃圾
- 引用计数法
    - 每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象
    - 循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低
- 可达性分析，又称引用链法（Tracing GC）  
从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活/死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉
    - GC ROOT
        1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象 ；
        2. 方法区中的类静态属性引用的对象 ；
        3. 方法区中的常量引用的对象 ；
        4. 本地方法栈中JNI的引用的对象；

### 收集算法
- 标记-清除  
回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效
- 标记-整理  
这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。主要实现有双指针（Two-Finger）回收算法、滑动回收（Lisp2）算法和引线整理（Threaded Compaction）算法等
- Copying（复制  将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。有递归（Robert R. Fenichel 和 Jerome C. Yochelson提出）和迭代（Cheney 提出）算法，以及解决了前两者递归栈、缓存行等问题的近似优先搜索算法。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高的缺点，另外就是存活对象比较大时复制的成本比较高

### 收集器
- Serial
    - 工作区域
        - 新生代：复制算法，串行
        - 老年代： 标记整理，串行
    - 使用一个线程去回收。垃圾收集的过程中会Stop The World（服务暂停）
    - 参数控制：-XX:+UseSerialGC  串行收集器
- ParNew，Serial的多线程版本
    - 工作区域
        - 新生代：复制算法，并行（主要用于新生代）
        - 老年代： 标记整理，串行
    - 参数控制：-XX:+UseParNewGC  ParNew收集器 XX:ParallelGCThreads 限制线程数量
- CMS  
    - 工作区域
        - 老年代：标记-清除
    - 以获取最短回收停顿时间为目标
    - 分4 大步进行垃圾收集
        - 初始标记(STW)
            - 标记一下GC Roots能直接关联到的对象，速度很快（标记出root节点）
        - 并发标记(与用户线程一起)
            - 进行GC Roots搜索可达的对象
        - 重新标记(STW)
            - 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短
        - 并发清除（与用户线程一起）
            - 清除对象
            - 产生浮动垃圾：由于是并发进行，重新标记的存活的对象如果此时变得不可达，无法清除，产生浮动垃圾
    - 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行
    - 优点:并发收集、低停顿
    - 缺点：产生大量空间碎片、并发阶段会降低吞吐量
    - 参数控制：
        - XX:+UseConcMarkSweepGC  使用CMS收集器
        - XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
        - XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理
        - XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）

### G1收集器
通过自动调整堆空间大小，来控制GC频率 

堆内存会被分配多个固定大小的区域，默认2048个，每个区域都被标记了E,S,O,H
- eden区
- survivor
- 老年代
- 巨型对象区

