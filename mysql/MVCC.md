为了提高常见场景下的性能，将需要加锁的位置变成不用加锁的mvcc方式，也就是读写不冲突，也就避免了脏读的现象

### 版本链
- trx_id  
每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列

- roll_pointer  
每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息

每条记录的改动都会生成一条undo日志，这些记录通过roll_pointer形成链表，其中包含了事务id

### readView
- 生成readView是活跃的事务id列表[min_trx_id, max_trx_id)
- 生成readView的creator_trx_id

存在下面几种情况
- 访问的trx_id < min_trx_id，可以被访问
- 访问的trx_id >= max_trx_id，不可以访问
- 访问的trx_id = creator_trx_id，可以访问
- 访问的trx_id大小在活跃的事务id列表之间，但是trx_id不在列表中，可以访问
- 访问的trx_id大小在活跃的事务id列表之间，但是trx_id在列表中，不可以访问

根据上面的可见性情况，对于某条记录，若该事务id不可见，则在版本链中一直找可见的版本

### 未提交读事务级别
直接读取最新的版本即可

### 串行化级别
采用加锁的方式

### 提交读事务级别
每次查询开始就会生成一个readView

### 可重复读事务级别
在第一次读时生成readView，解决了幻读的问题（trx_id大于max_trx_id）