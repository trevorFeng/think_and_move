### GC工作区域
- heap区（堆）
- MetaSpace 区(替代已有的方法区)
- -XX:MaxPermSize设置大小

### GC时机
- Minor GC触发条件：当Eden区满时，触发Minor GC
- Full GC触发条件
    - 老年代空间不足
    - 方法去空间不足
    - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    - 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小


### 找到垃圾
- 引用计数法
    - 每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象
    - 循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低
- 可达性分析，又称引用链法（Tracing GC）  
从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活/死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉
    - GC ROOT
        1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象 ；
        2. 方法区中的类静态属性引用的对象 ；
        3. 方法区中的常量引用的对象 ；
        4. 本地方法栈中JNI的引用的对象；

### 收集算法
- 标记-清除  
回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效
- 标记-整理  
这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。主要实现有双指针（Two-Finger）回收算法、滑动回收（Lisp2）算法和引线整理（Threaded Compaction）算法等
- Copying（复制  将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。有递归（Robert R. Fenichel 和 Jerome C. Yochelson提出）和迭代（Cheney 提出）算法，以及解决了前两者递归栈、缓存行等问题的近似优先搜索算法。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高的缺点，另外就是存活对象比较大时复制的成本比较高

### 收集器
- Serial
    - 工作区域
        - 新生代：复制算法，串行
        - 老年代： 标记整理，串行
    - 使用一个线程去回收。垃圾收集的过程中会Stop The World（服务暂停）
    - 参数控制：-XX:+UseSerialGC  串行收集器
- ParNew，Serial的多线程版本
    - 工作区域
        - 新生代：复制算法，并行（主要用于新生代）
        - 老年代： 标记整理，串行
    - 参数控制：-XX:+UseParNewGC  ParNew收集器 XX:ParallelGCThreads 限制线程数量

### CMS收集器
不是full gc，周期性的检查老年代情况，达到老年代内存阈值则进行CMS gc针对老年代，使用标记清除算法，以获取最短停顿时间为目标的收集器

- 初始标记STW    
进行可达性分析，标记直接关联的对象

- 并发标记  
与用户线程一起，通过前一阶段标记的对象出发，标记所有可达的对象

- 并发预清理（存在新生代引用老年代的情况）  
此阶段标记从新生代晋升的对象、新分配到老年代的对象以及在并发阶段被修改了的对象 
    - 新生代：可配置参数强制进行一次minor GC
    - 老年代：使用card table的数组，每个位置存一个byte，CMS将老年代分为大小为512bytes的块，card table中每个元素对应一个块，
    并发标记时，如果对象的引用发生了变化，就标记该对象所在的块为dirty card，预清理阶段会重新扫描该块，将该对象引用的对象变为可达
    （card table 其他作用：存放老年代对新生代的引用，minor GC通过扫描card table可以很快识别新生代那些对象被老年代引用着）
    
- 重标记（STW）  
进行可达性分析，标记存活的对象，有预清理阶段为基础，这个阶段工作会很轻松

- 并发清理  
与用户线程一起，清理死亡的对象
    - 此阶段可能产生新的垃圾，本次GC无法清除，产生浮动垃圾

由于并发清理时，用户线程也在运行，所以必须预留一些老年代内存给用户线程，可以设置参数老年代空间百分比，达到就进行垃圾回收
默认时92%，太高可能导致用户线程使用空间不足，导致Serial Old收集器重新对老年代进行垃圾回收，太低GC频繁

由于使用的时标记清除算法，产生了内存碎片，所以可配置参数在进行full gc后进行内存整理


### G1收集器
通过自动调整堆空间大小，来控制GC频率 

堆内存会被分配多个固定大小的区域，默认2048个，每个区域都被标记了E,S,O,H
- eden区
- survivor
- 老年代
- 巨型对象区

卡片
- 每个分区分为了若干个512bytes卡片，查找分区的对象引用可通过记录卡片查找该引用对象，每次内存的回收，都是针对卡片

##### YGC
当Eden区满了之后就会触发YGC，依旧采用复制到survivor区的方式，当对像年龄满足晋升条件后，晋升到老年代

G1控制YGC开销的手段是动态改变young region的个数，YGC的过程中依然会STW(stop the world 应用停顿)，并采用多线程并发复制对象，减少GC停顿时间。
采用了Rset结构，每个region都有自己的Rset，记录了其他region中的对象引用本region中对象的关系。Rset实际上时hash table，key是region的index，value是card数组
，数组内存放card的index

在YGC的时候选定年轻代的region的Rset，就可以知道哪些老年代引用年轻代，大大减少了GC工作量

##### MIXGC
当老年代占用空间超过整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent(默认45%)时



